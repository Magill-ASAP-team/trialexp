' first&last |$ first bar_off, last_bar_off_before_first_spout, first_spout

var list%[401];

var vh% :=View();
if ViewKind(vh%) <> 0 then
    halt;
endif

var chanmk%;
var chand%;
var code% := 1;
var mask%[256];
var i%;

ChanList(list%[], 2+4+8+16+32+2048 + 16384);


var chan_trial_onset%;
var chan_bar_off%;
var chan_spout%;
var chan_break_after_trial%;

var isfound_chan_trial_onset% :=0;
var isfound_chan_bar_off% :=0;
var isfound_chan_spout% :=0;
var isfound_chan_break_after_trial% :=0;


for i% := 0 to list%[0] do
    docase
        case ChanTitle$(list%[i%]) = "hold_for_water" then
            if isfound_chan_trial_onset% then
                PrintLog("hold_for_water found more than once!");
            endif
            chan_trial_onset% := list%[i%];
            isfound_chan_trial_onset% := 1;
    case ChanTitle$(list%[i%]) = "bar_off" then
            if isfound_chan_bar_off% then
                PrintLog("bar_off found more than once!");
            endif        
            chan_bar_off% := list%[i%];
            isfound_chan_bar_off%:=1;
    case ChanTitle$(list%[i%]) = "spout" then
            if isfound_chan_bar_off% then
                PrintLog("spout found more than once!");
            endif          
            chan_spout% := list%[i%];
        isfound_chan_spout% :=1;
    case ChanTitle$(list%[i%]) = "break_after_trial" then
            if isfound_chan_break_after_trial% then
                PrintLog("spout found more than once!");
            endif          
            isfound_chan_break_after_trial% :=1;
        
            chan_break_after_trial% := ChanDuplicate(list%[i%]); 'Create a duplicate
            ChanShow(chan_break_after_trial%);
            ' just keep 01
            MarkMask(chan_break_after_trial%, -1, 1, -1); 'Set filter to all pass
            MarkMask(chan_break_after_trial%, 0, -1, -1); 'Invert all code
            MarkMask(chan_break_after_trial%, 0, 1, 1);
            MarkShow(chan_break_after_trial%, 0, 0); 'Set marker to display and mode
            DrawMode(chan_break_after_trial%,2,1, 0,0); 'Set Lines
    endcase;
next;

var this_trial :=0;
var first_spout;
var trial_end;
var first_bar_off;
var last_bar_off_before_first_spout;

var chan_first_bar_off% := MemChan(2); 'Add new Event- channel
ChanTitle$(chan_first_bar_off%, "first_bar_off");
Chanshow(chan_first_bar_off%);

var chan_first_spout% := MemChan(2); 'Add new Event- channel
ChanTitle$(chan_first_spout%, "first_spout");
Chanshow(chan_first_spout%);

var chan_last_bar_off_before_first_spout% := MemChan(2); 'Add new Event- channel
ChanTitle$(chan_last_bar_off_before_first_spout%, "last_bar_off");
Chanshow(chan_last_bar_off_before_first_spout%);


while NextTime(chan_trial_onset%, this_trial) > 0 do
    ' start from hold_for_water to another
    this_trial := NextTime(chan_trial_onset%, this_trial);
    trial_end := NextTime(chan_break_after_trial%, this_trial);
    if trial_end < 0 then
        break
    endif
    
    first_bar_off := ChanSearch(chan_bar_off%, 14, this_trial, trial_end);
    if first_bar_off = -1 then
        ' hoge
    else
        MemSetItem(chan_first_bar_off%, 0, first_bar_off);
    endif
    
    first_spout := ChanSearch(chan_spout%, 14, this_trial, trial_end);
    if first_spout = -1 then
        ' hoge
    else
        MemSetItem(chan_first_spout%, 0, first_spout);
        
            last_bar_off_before_first_spout := ChanSearch(chan_bar_off%, 14, first_spout, this_trial);
            if first_spout = -1 then
                ' hoge
            else
                MemSetItem(chan_last_bar_off_before_first_spout%, 0, last_bar_off_before_first_spout);
            endif 
    endif

wend



'### create waveform average

var list$[400];
var chosen%[12];
for i% := 0 to 11 do;
     chosen%[i%] := 0;
next

' reset
for i% := 0 to 400 do;
    list%[i%] := 0;
next

ChanList(list%[], 1+2048);
for i% := 0 to list%[0] do;
    list$[i%] := ChanTitle$(list%[i%+1]);
    chosen%[i%] := 1;
next


DlgCreate("Choose channels to plot");
DlgAllow(1+2+4+8+16+32+128);

for i% := 0 to 11 do;
    DlgCheck(i%, list$[i%+1]);
next
'TODO not all the waveform channels are shown
var ok% := DlgShow(chosen%[0], chosen%[1],chosen%[2], chosen%[3], chosen%[4],chosen%[5],chosen%[6],chosen%[7],chosen%[8],chosen%[9], chosen%[10],chosen%[11]);

if ok% =0 then
    halt
endif

var selected_chans$ := "";
var wfchan1% := list%[1];
for i% := 0 to 11 do;
    if chosen%[i%] then
        if selected_chans$ <> "" then
            wfchan1% := list%[i%+1];
            selected_chans$ := selected_chans$ + ",";
        endif

        selected_chans$ := selected_chans$ + Str$(list%[i%+1]);
        
    endif
next

var res_win%;

var trig;
var win := 4;
var offset := 2;


DlgCreate("Choose a trigger channel");
DlgAllow(1+2+4+8+16+32+128);
DlgChan(1, "Trigger", 2+4+8+16+32+64+2048);
DlgReal(2, "Window (s)", 0, 15);
DlgReal(3, "Offset (s)", 0, 15);
DlgButton(1, "&Close");
DlgButton(2, "&Plot||plot Waveform Average", wave_ave%);

ok% := DlgShow(trig, win, offset);
'default value of win and offset are not working



func wave_ave%()

var bins% := Round(DlgValue(2) / Binsize(wfchan1%));

if bins% =0 then
    PrintLog("Error: bins% is 0. Shoule be greater than 0.");
    Halt
endif

'TODO trig must be an integer
var trig% := DlgValue(1);

res_win% := SetAverage(selected_chans$, bins%, DlgValue(3), trig%, 1, 1);
WindowVisible(1);
Process(0.0, MaxTime(), 1, 1);

return 1;
end


